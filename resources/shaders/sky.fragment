/* Simple fragment shader for drawing a 2d geometry with texture to screen
 */ 
#version 140
	

uniform vec3 sunVector;
uniform float sunIntensity;

uniform mat4 inv_proj;
uniform mat4 inv_view;

uniform float step_count = 10.0;

// How much the atmosphere scatters each channel
uniform vec3 Kr = vec3(
			0.3, 0.5, 0.8
		);


// corresponds with output from vertex shader, gets interpolated
in vec4 FragCoord;
 
// output to buffer
out vec4 FragColor;

// Calculates how much light is scattered in a direction where
// alpha is the angle between the original direction and the
// new direction
float phase(float alpha, float g){
	float a = 3.0*(1.0-g*g);
	float b = 2.0*(2.0+g*g);
	float c = 1.0+alpha*alpha;
	float d = pow(1.0+g*g-2.0*g*alpha, 1.5);
	return (a/b)*(c/d);
}

float atmospheric_depth(vec3 position, vec3 dir){
	// pitch + pi / 2
	float pitch = asin(dir.y);
	float a = pitch + 1.5708;
	float sina = sin(a);

	// Handle the edge case where sina ~= 0
	if(abs(pitch-1.5708) < 0.2) return 1 - position.y;

	return sin(3.14159 - a - asin(position.y * sina))/sina;
}

// Calculates how much light is blocked by the horizon
float horizon_extinction(vec3 position, vec3 dir, float radius){
	float u = dot(dir, -position);
	if(u<0.0){
		return 1.0;
	}
	vec3 near = position + u*dir;
	if(length(near) < radius){
		return 0.0;
	}else{
		vec3 v2 = normalize(near)*radius - position;
		float diff = acos(dot(normalize(v2), dir));
		return smoothstep(0.0, 1.0, pow(diff*2.0, 3.0));
	}
}


// color - color * Kr^(factor/distance)
vec3 extinction(float dist, vec3 color, float factor){
	return color-color*pow(Kr, vec3(factor/dist));
}

void main()
{
	float rayleigh_brightness = 1.0;
	float mie_brightness = 1.0;

	// Ratio of earth radius to radius + atmosphere
	float surface_height = 0.9953;
	float scatter_strength = 1.0;

	// Size of mie scattering particles
	float mie_distribution = 0.9999;

	// Calculate the vector from the camera to the fragment
	vec4 device_normal = vec4(FragCoord.xy, 0, 1.0);
	vec3 eye_normal = normalize((inv_proj * device_normal).xyz);
	vec3 eyeVector = normalize(mat3(inv_view) * eye_normal);

	// Measure of how parrallel the eye and sun vectors are
	float alpha = dot(eyeVector, sunVector);

	// Calculates a factor for each type of scattering based on the size
	// of the particles, and the relative brightness
	float rayleigh_factor = phase(alpha, 0.0)*rayleigh_brightness;
	float mie_factor = phase(alpha, mie_distribution)*mie_brightness;


	// How much atmosphere does a ray coming from the eye have to travel through
	vec3 eye_position = vec3(0.0, surface_height, 0.0);
	float eye_depth = atmospheric_depth(eye_position, eyeVector.xyz);
	float step_length = eye_depth / float(step_count);

	vec3 rayleigh_collected = vec3(0.0, 0.0, 0.0);
	vec3 mie_collected = vec3(0.0, 0.0, 0.0);

	for(int i=0; i<step_count; i++){
		// Calculate the sample position in worldspace
		float sample_distance = step_length*float(i);
		vec3 position = eye_position + eyeVector.xyz*sample_distance;

		float hextinction = horizon_extinction(
				position, sunVector, surface_height-0.35
			);

		// How much of the ray cast from the eye to the sun is in the atmosphere
		float sample_depth = atmospheric_depth(position, sunVector);

		// Amount of sunlight that makes it through the atmosphere to the sample position
		vec3 influx = extinction(sample_depth, vec3(sunIntensity), scatter_strength)*hextinction;

		// Amount of light that is in-scattered due to each type of scattering and makes it through
		// the atmosphere from the sample point to the viewer
		rayleigh_collected += extinction(sample_distance, Kr*influx, scatter_strength);
		mie_collected += extinction(sample_distance, influx, scatter_strength);
	}

	// Calculate the horizon
	float eye_extinction = horizon_extinction(
			    eye_position, eyeVector.xyz, surface_height-0.15
			);

	// Apply the horizon and scale the result
	rayleigh_collected = (
			rayleigh_collected *
			eye_extinction
		)/float(step_count);

	mie_collected = (
			mie_collected *
			eye_extinction
		)/float(step_count);


	// Calculate the final color by apply the amount of light that is inscattered
	vec3 color = vec3(
			mie_factor * mie_collected +
			rayleigh_collected
		);
	FragColor = vec4(color, 0);
} 

